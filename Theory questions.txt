1. Что подразумевается под тестовой средой.
     Среда тестирования — это настройка программного и аппаратного обеспечения для групп тестирования для выполнения тестовых случаев.
Испытательный стенд или тестовая среда настраиваются в соответствии с требованиями тестируемого приложения. В некоторых случаях испытательный стенд может представлять собой комбинацию тестовой среды и тестовых данных, которые он использует.
     Для тестовой среды ключевая область для настройки включает в себя:
*Система и приложения
*Тестовые данные
*Сервер базы данных
*Фронтальная рабочая среда
*Клиентская операционная система
*Браузер
*Аппаратное обеспечение включает операционную систему сервера
*Сеть
*Документация, такая как справочные документы, руководства по конфигурации,руководства по установке,руководства пользователя
     Список действий функции управления тестовой средой включает в себя:
1)Поддержка центрального репозитория со всеми обновленными версиями тестовых сред
2)Управление средой тестирования в соответствии с требованиями команды тестирования
3)Согласно новым требованиям, создающим новые среды
4)Мониторинг окружающей среды
5)Обновление / удаление устаревших тестовых сред
6)Исследование проблем окружающей среды
7)Координация до разрешения вопроса.
     Испытательный стенд - это среда разработки программного обеспечения. Это позволяет разработчикам тестировать свои модули, не затрагивая рабочие серверы. Стенд предназначен не только для разработчиков, но и для тестировщиков. Это также называется тестовой средой.

====================================================================================================================================

2. В чем отличие build от release
Билд это номер, даваемый ПО при передаче от разработчиков тестировщикам. Релиз — это номер, даваемый ПО при передаче конечному пользователю.

====================================================================================================================================

3. Основные фазы тестирования?
   Pre-Alpha: ПО является прототипом. Пользовательский интерфейс завершен, но не все функции завершены. На данном этапе ПО не публикуется. 
   Alpha: является ранней версией программного продукта. Цель - вовлечь клиента в процесс разработки. Хороший Альфа-тест должен иметь четко определенный план тестирования с комплексными тестовыми примерами. Это дает лучшее представление о надежности программного обеспечения на ранних стадиях. В некоторых случаях тестирование может быть передано на аутсорс. 
   Beta: ПО стабильно и выпускается для ограниченной пользовательской базы. Цель состоит в том, чтобы получить отзывы клиентов о продукте и внести соответствующие изменения в ПО. 
   Release Candidate (RC): основываясь на отзывах Beta Test, вы вносите изменения в ПО и хотите проверить исправления ошибок. На этом этапе вы не хотите вносить радикальные изменения в функциональность, а просто проверяете наличие ошибок. RC также выпущен для пользователей.
   Release: Все работает, ПО выпущено для пользователей. 

====================================================================================================================================

4. Что такое импакт анализ?
     Основная идея импакт анализа — это указание затронутых мест в проекте при разработке новой или изменении старой функциональности. Во время разработки часто возникают ситуации, когда вносишь изменения в одном месте, а это влияет либо на весь проект либо на несколько мест в проекте. При таких изменениях сложно вспомнить и протестировать все необходимые места, особенно если они не покрыты тестами. В результате этого, после сдачи очередного релиза, клиенты начинают обращаться с жалобами на то, что что-то поломалось или не работает.
     Импакт анализ может быть полезным в следующих случаях:
*есть изменения в требованиях;
*получен запрос на внесение изменений в продукт;
*ожидается внедрение нового модуля или функциональности в существующий продукт;
*каждый раз, когда есть изменения в существующих модулях или функциональностях продукта.
Как мы знаем, в настоящее время продукты становятся всё более большими и комплексными, а компоненты всё чаще зависят друг от друга. Изменение строчки кода в таком проекте может "сломать" абсолютно всё.

====================================================================================================================================

5. Критерии выбора тестов?
Требования к идеальному критерию тестирования:
  1)Критерий должен быть достаточным, т.е. показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы.
  2)Критерий должен быть полным, т.е. в случае ошибки должен существовать тест из множества тестов, удовлетворяющих критерию, который раскрывает ошибку.
  3)Критерий должен быть надежным, т.е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы.
  4)Критерий должен быть легко проверяемым, например вычисляемым на тестах.
Для нетривиальных классов программ в общем случае не существует полного и надежного критерия, зависящего от программ или спецификаций. Поэтому мы стремимся к идеальному общему критерию через реальные частные. 
     Классы критериев:
 -Структурные критерии используют информацию о структуре программы (критерии так называемого "белого ящика").
 -Функциональные критерии формулируются в описании требований к программному изделию ( критерии так называемого "черного ящика" ).
 -Критерии стохастического тестирования формулируются в терминах проверки наличия заданных свойств у тестируемого приложения, средствами проверки некоторой статистической гипотезы.
 -Мутационные критерии ориентированы на проверку свойств программного изделия на основе подхода Монте-Карло.
     Структурные критерии используют модель программы в виде "белого ящика", что предполагает знание исходного текста программы или спецификации программы в виде потокового графа управления. Структурная информация понятна и доступна разработчикам подсистем и модулей приложения, поэтому данный класс критериев часто используется на этапах модульного и интеграционного тестирования (Unit testing, Integration testing). Структурные критерии базируются на основных элементах УГП (Управляющий граф программы), операторах, ветвях и путях.
   Условие критерия тестирования команд (критерий С0) - набор тестов в совокупности должен обеспечить прохождение каждой команды не менее одного раза. Это слабый критерий, он, как правило, используется в больших программных системах, где другие критерии применить невозможно.
   Условие критерия тестирования ветвей (критерий С1) - набор тестов в совокупности должен обеспечить прохождение каждой ветви не менее одного раза. Это достаточно сильный и при этом экономичный критерий, поскольку множество ветвей в тестируемом приложении конечно и не так уж велико. Данный критерий часто используется в системах автоматизации тестирования.
   Условие критерия тестирования путей (критерий С2) - набор тестов в совокупности должен обеспечить прохождение каждого пути не менее 1 раза. Если программа содержит цикл (в особенности с неявно заданным числом итераций), то число итераций ограничивается константой (часто - 2, или числом классов выходных путей).
Структурные критерии не проверяют соответствие спецификации, если оно не отражено в структуре программы. Поэтому при успешном тестировании программы по критерию C2 мы можем не заметить ошибку, связанную с невыполнением некоторых условий спецификации требований. 
     Функциональный критерий - важнейший для программной индустрии критерий тестирования. Он обеспечивает, прежде всего, контроль степени выполнения требований заказчика в программном продукте. Поскольку требования формулируются к продукту в целом, они отражают взаимодействие тестируемого приложения с окружением. При функциональном тестировании преимущественно используется модель "черного ящика". Проблема функционального тестирования - это, прежде всего, трудоемкость; дело в том, что документы, фиксирующие требования к программному изделию (Software requirement specification, Functional specification и т.п.), как правило, достаточно объемны, тем не менее, соответствующая проверка должна быть всеобъемлющей. Ниже приведены частные виды функциональных критериев:
   -Тестирование пунктов спецификации - набор тестов в совокупности должен обеспечить проверку каждого тестируемого пункта не менее одного раза. Спецификация требований может содержать сотни и тысячи пунктов требований к программному продукту и каждое из этих требований при тестировании должно быть проверено в соответствии с критерием не менее чем одним тестом.
   -Тестирование классов входных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого класса входных данных не менее одного раза. При создании тестов классы входных данных сопоставляются с режимами использования тестируемого компонента или подсистемы приложения, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов. Следует заметить, что перебирая в соответствии с критерием величины входных переменных (например, различные файлы - источники входных данных), мы вынуждены применять мощные тестовые наборы. Действительно, наряду с ограничениями на величины входных данных, существуют ограничения на величины входных данных во всевозможных комбинациях, в том числе проверка реакций системы на появление ошибок в значениях или структурах входных данных. Учет этого многообразия - процесс трудоемкий, что создает сложности для применения критерия.
   -Тестирование правил - набор тестов в совокупности должен обеспечить проверку каждого правила, если входные и выходные значения описываются набором правил некоторой грамматики. Следует заметить, что грамматика должна быть достаточно простой, чтобы трудоемкость разработки соответствующего набора тестов была реальной (вписывалась в сроки и штат специалистов, выделенных для реализации фазы тестирования).
   -Тестирование классов выходных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого выходного класса, при условии, что выходные результаты заранее расклассифицированы, причем отдельные классы результатов учитывают, в том числе, ограничения на ресурсы или на время (time out). При создании тестов классы выходных данных сопоставляются с режимами использования тестируемого компонента или подсистемы, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов.
   -Тестирование функций - набор тестов в совокупности должен обеспечить проверку каждого действия, реализуемого тестируемым модулем, не менее одного раза. Очень популярный на практике критерий, который, однако, не обеспечивает покрытия части функциональности тестируемого компонента, связанной со структурными и поведенческими свойствами, описание которых не сосредоточено в отдельных функциях (т.е. описание рассредоточено по компоненту). Критерий тестирования функций объединяет отчасти особенности структурных и функциональных критериев. Он базируется на модели "полупрозрачного ящика", где явно указаны не только входы и выходы тестируемого компонента, но также состав и структура используемых методов (функций, процедур) и классов.
Комбинированные критерии для программ и спецификаций - набор тестов в совокупности должен обеспечить проверку всех комбинаций непротиворечивых условий программ и спецификаций не менее одного раза. При этом все комбинации непротиворечивых условий надо подтвердить, а условия противоречий следует обнаружить и ликвидировать.
Стохастическое тестирование применяется при тестировании сложных программных комплексов - когда набор детерминированных тестов (X,Y) имеет громадную мощность. Мутационный критерий (класс IV). Постулируется, что профессиональные программисты пишут сразу почти правильные программы, отличающиеся от правильных мелкими ошибками или описками типа - перестановка местами максимальных значений индексов в описании массивов, ошибки в знаках арифметических операций, занижение или завышение границы цикла на 1 и т.п. Предлагается подход, позволяющий на основе мелких ошибок оценить общее число ошибок, оставшихся в программе. Подход базируется на следующих понятиях: Мутации - мелкие ошибки в программе. Мутанты - программы, отличающиеся друг от друга мутациями . Метод мутационного тестирования - в разрабатываемую программу P вносят мутации, т.е. искусственно создают программы-мутанты P1, P2... Затем программа P и ее мутанты тестируются на одном и том же наборе тестов (X,Y). Если на наборе (X,Y) подтверждается правильность программы P и, кроме того, выявляются все внесенные в программы-мутанты ошибки, то набор тестов (X,Y) соответствует мутационному критерию, а тестируемая программа объявляется правильной. Если некоторые мутанты не выявили всех мутаций, то надо расширять набор тестов (X,Y) и продолжать тестирование.

====================================================================================================================================

6. Принципы тестирования?
*Тестирование демонстрирует наличие дефектов
*Исчерпывающее тестирование недостижимо
*Раннее тестирование
*Скопление/кластеризация дефектов
*Парадокс пестицида
*Тестирование зависит от контекста
*Заблуждение об отсутствии ошибок
*Garbage in, garbage out (GIGO)

Принцип 1. Тестирование показывает наличие дефектов 
Тестирование может показать, что дефекты присутствуют, но не может доказать, что дефектов нет. Сколько бы успешных тестов вы не провели, вы не можете утверждать, что нет таких тестов, которые не нашли бы ошибку. Но если мы нашли хотя бы один дефект, мы уже можем утверждать, что в данном ПО присутствуют дефекты.

Принцип 2. Исчерпывающее тестирование невозможно 
Вместо попыток «протестировать все» нам нужен некий подход к тестированию (стратегия), который обеспечит правильный объем тестирования для данного проекта, данных заказчиков (и других заинтересованных лиц) и данного продукта. При определении, какой объем тестирования достаточен, необходимо учитывать уровень риска, включая технические риски и риски, связанные с бизнесом, и такие ограничения проекта как время и бюджет. Оценка и управление рисками – одна из наиболее важных активностей в любом проекте. 

Принцип 3. Раннее тестирование 
Тестовые активности должны начинаться как можно раньше в цикле разработки и быть сфокусированы на определенных целях. Этот принцип связан с понятием «цена дефекта» (cost of defect). Цена дефекта существенно растет на протяжении жизненного цикла разработки ПО. Чем раньше обнаружен дефект, тем быстрее, проще и дешевле его исправить. Дефект, найденный в требованиях, обходится дешевле всего. Еще одно важное преимущество раннего тестирования – экономия времени. Тестовые активности могут начинаться еще до того, как написана первая строчка кода. По мере того, как готовятся требования и спецификации, тестировщики могут приступать к разработке и ревью тест-кейсов. И когда появится первая тестовая версия, можно будет сразу приступать к выполнению тестов.

Принцип 4. Скопление дефектов 
Небольшое количество модулей содержит большинство дефектов, обнаруженных на этапе предрелизного тестирования, или же демонстрируют наибольшее количество отказов на этапе эксплуатации. Многие тестировщики наблюдали такой эффект – дефекты «кучкуются». Это может происходить потому, что определенная область кода особенно сложна и запутана, или потому, что внесение изменений производит «эффект домино». Это знание часто используется для оценки рисков при планировании тестов – тестировщики фокусируются на известных «проблемных зонах». Также полезно проводить анализ первопричин (root cause analysis), чтобы предотвратить повторное появление дефектов, обнаружить причины возникновения скоплений дефектов и спрогнозировать потенциальные скопления дефектов в будущем.

Принцип 5. Парадокс пестицида
 Если повторять те же тесты снова и снова, в какой-то момент этот набор тестов перестанет выявлять новые дефекты. Повторное применение тех же тестов и тех же методик приводит к тому, что в продукте остаются именно те дефекты, против которых эти тесты и эти методики неэффективны. Чтобы преодолеть «парадокс пестицидов», необходимо регулярно пересматривать существующие тест-кейсы и создавать новые, разнообразные тесты, которые будут выполняться на различных частях системы.   

Принцип 6. Тестирование зависит от контекста
 Тестирование выполняется по-разному, в зависимости от контекста. Например, тестирование систем, критических с точки зрения безопасности, проводится иначе, чем тестирование сайта интернет-магазина. Этот принцип тесно связан с понятием риска. Что такое риск? Риск – это потенциальная проблема. У риска есть вероятность (likelihood) – она всегда выше 0 и ниже 100% – и есть влияние (impact) – те негативные последствия, которых мы опасаемся. Анализируя риски, мы всегда взвешиваем эти два аспекта: вероятность и влияние. То же можно сказать и о мире ПО: разные системы связаны с различными уровнями риска, влияние того или иного дефекта также сильно варьируется. Одни проблемы довольно тривиальны, другие могут дорого обойтись и привести к большим потерям денег, времени, деловой репутации, а в некоторых случаях даже привести к травмам и смерти. Уровень риска влияет на выбор методологий, техник и типов тестирования.

Принцип 7. Заблуждение об отсутствии ошибок 
Нахождение и исправление дефектов бесполезно, если построенная система неудобна для использования и не соответствует нуждам и ожиданиям пользователей. Заказчики ПО – люди и организации, которые покупают и используют его, чтобы выполнять свои повседневные задачи – на самом деле совершенно не интересуются дефектами и их количеством, кроме тех случаев, когда они непосредственно сталкиваются с нестабильностью продукта. Им также неинтересно, насколько ПО соответствует формальным требованиям, которые были задокументированы. Пользователи ПО более заинтересованы в том, чтобы оно помогало им эффективно выполнять задачи. ПО должно отвечать их потребностям, и именно с этой точки зрения они его оценивают. Даже если вы выполнили все тесты и ошибок не обнаружили, это еще не гарантия того, что ПО будет соответствовать нуждам и ожиданиям пользователей. Иначе говоря, верификация != валидация.

Принцип 8. GIGO.
 В компьютерной науке «garbage in – garbage out» (GIGO) — это концепция, в которой ошибочные или бессмысленные входные данные создают бессмысленный вывод или «мусор», т.е. при неверных входящих данных будут получены неверные результаты, даже если сам по себе алгоритм правилен. В тестировании такие случаи иногда создают намеренно, но я добавил этот принцип в общий список для того, чтобы подчеркнуть важность подготовки качественных тестовых данных, положительные они или отрицательные.

====================================================================================================================================

7. Что такое независимое тестирование?
     Независимое тестирование (аутсорсинг тестирования) - это тестирование силами дополнительно привлечённой компании или группы людей, не участвующих непосредственно в разработке программного обеспечения. Данный подход имеет ряд положительных особенностей, позволяющих существенно повысить качество создаваемого программного продукта.
     Из самой идеи независимого тестирования следует, что работа выполняется группой людей, которые не находятся в прямом подчинении руководителя разработки программного проекта. Отсюда следует ряд важных следствий, связанных с организацией труда тестеров. Полностью исключается давление на тестеров со стороны разработчиков, как правило, ведущее к сокращению времени, выделяемого на тестирование. Тестеры работают в нормальном режиме, не подвергаются стрессовым нагрузкам, что резко снижает риски, связанные с некачественным выполнением работ по тестированию. Более того, руководителем разработки не указываются "приоритетные направления тестирования", независимые тестеры смотрят на программный продукт шире и самостоятельнее. Наконец, люди, которые начинают тестировать программу впервые, смотрят на неё "другими" глазами, чем программисты и тестеры из отдела качества компании-разработчика ПО.
     Как правило, сотрудники компании, выполняющей независимое тестирование, обладают большей квалификацией, чем персонал тестеров разработчика ПО. Для этого существуют организационные предпосылки:
-как правило, внутренние тестеры компании-разработчика имеют квалификацию ниже, чем программисты и системные аналитики, получая, соответственно, меньшую зарплату;
-при увеличении квалификации тестера он переводится в программисты;
-тестер выполняет проверку одного и того же ПО, не расширяя свой кругозор;
между выпусками версий ПО тестер недогружен и привлекается к выполнению не связанных с тестированием работ.
     Недостаток обучения и переподготовки персонала является для многих компаний основной причиной невысокого качества проведения тестирования. В противоположность этому персонал компании, проводящей независимое тестирование, специально обучен и мотивирован на нахождение максимального количества дефектов в тестируемом ПО.
     Мир программирования развивается достаточно динамично, поэтому новые методики, техники тестирования, инструменты автоматизации появляются несколько раз в год. Зачастую отделы внутреннего тестирования не могут позволить себе приобрести дорогостоящий инструмент автоматизации или провести переподготовку персонала. Такая ситуация неминуемо ведёт к снижению качества ПО.
     В этих условиях независимое тестирование становится единственным объективным способом оценки качества программного обеспечения, минимизации рисков и неопределенности. Аутсорсинг тестирования позволяет переложить на Исполнителя все заботы, связанные с:
*Наличием ресурсов для тестирования;
*Квалификацией и опытом;
*Знанием специфики;
*Компетенцией;
*Проблемами с персоналом;
*Адаптацией к меняющимся требованиям;
*Снижением времени вывода продукта на рынок.

====================================================================================================================================

8.Что такое тестирование со сдвигом влево?
     В попытке перенести тестирование на более ранний этап жизненного цикла разработки при одновременном улучшении показателей качества, задачи смещаются влево в схеме жизненного цикла разработки ПО. По возможности, тестирование должно проводиться с самого начала фазы проектирования, чтобы построить соответствующую стратегию тестирования. Проще говоря, это подход к тестированию программного обеспечения и тестированию системы, при котором тестирование выполняется на более раннем этапе жизненного цикла. Ключевые преимущества:
-Сокращение затрат
-Более высокое качество
-Повышение эффективности
-Конкурентные преимущества

====================================================================================================================================

9.Почему тестирование делится на отдельные этапы?
   *Каждый этап испытаний имеет свое назначение
   *Проще управлять поэтапно
   *Мы можем запустить разные тесты в разных средах
   *Производительность и качество тестирования улучшаются с помощью поэтапного тестирования

====================================================================================================================================

10.Какие есть этапы тестирования?
    - Работа с требованиями. Знакомство с требованиями заказчика, что должен из себя представлять итоговый продукт, обсуждение.
     -Разработка стратегии тестирования. Оценка сроков тестирования, выявление среды тестирования, объединение всей информации, полученной при работе с требованиями.
    -Создание тестовой документации. Написание сценариев, которые позволят проверить функционал.
    -Тестирование прототипа. Тестирование основного функционала продукта, корректировка целей, добавление фичей.
    -Основное тестирование. Выполнение общей проверки продукта.
    -Стабилизация. На данном этапе происходит работа над устранением багов.
    -Эксплуатация. Проводится регресс-тестирование, устранение ошибок, которые нашел конечный пользователь.
Прежде, чем переходить к описанию каждого цикла тестирования, необходимо запомнить важное правило: переход к следующему этапу допустим лишь после полного завершения работы на предыдущем. Теперь поговорим о каждом этапе тестирования отдельно.

Этап 1. Работа с требованиями
     Команда тестирования знакомится с требованиями заказчика, функционалом продукта. На данном этапе важно непрерывное общение команд, необходимо задавать вопросы разработчикам.
Тщательное изучение требований должно:
-выявить противоречия в требованиях;
-помочь определить потенциальные дефекты в функционале.
     Общение является ключевым аспектом в разработке продукта, а продуманный roadmap (дорожная карта, стратегический план по реализации функционала продукта по определенным датам) позволит устранить нелогичность будущих внесенных изменений в продукт.

Этап 2. Разработка стратегии тестирования и планирование процедур контроля качества
Данный этап важен для лидов или менеджеров, поскольку от понимания полученной на предыдущем этапе информации зависит качество тестирования. 
Тест — лид должен: 
-резюмировать полученную информацию, 
-оценить сроки тестирования, 
-разработать стратегию тестирования: определить виды тестирования, которые можно применить к проекту, проанализировать имеющиеся среды и ресурсы, что имеется для проведения тестирования, описать приоритеты для непредвиденных ситуаций, как и где будет вестись тестовая документация; 
-определение среды тестирования: какое оборудование необходимо для тестирования,
-составить план, который содержит описание, с чего начинается и чем заканчивается тестирование, и что будет тестироваться.

Этап 3. Создание тестовой документации
Цель данного этапа – создать документацию, объем которой будет охватывать детализацию, ход работ, а также вносить ясность для заказчика.
Общение с другими командами, понимание желаний заказчика напрямую влияют на качество тестовой документации. После проведенного тестирования можно проанализировать его успешность.
Тестовая документация может состоять из:
-тестовых сценариев: что и как будет проверяться при регресс-, дымовом и приемочном тестированиях;
-отчетности: результаты тестирования, списка багов и их серьезность;
-методологий тестирования.
Детализация тестовой документации зависит от проекта, поэтому она может отличаться и по охвату, и по формату, и по объему. Для тестировщика важно поддерживать документацию в актуальном виде, вносить любые изменения, связанные с изменением итогового продукта.

Этап 4.  Тестирование прототипа
     При создании и тестировании прототипа продукта необходимо выявить основные отклонения от ожидаемого результата и соответствие с бизнес-стратегией. Здесь же выявляются ошибки в работе логики основного функционала, устраняются найденные уязвимости и дефекты, допущенные на этапе разработки. Заказчик может сам участвовать в процессе тестирования прототипа, чтобы он мог оценить, на каком этапе находится разработка продукта. После тестирования выдвигаются пожелания со стороны заказчика. Новые пожелания необходимо задокументировать, оценить сроки, внедрить в проект и передать на осмотр заказчику.
    Самый подходящий метод тестирования прототипа – проведение закрытого бета-тестирования, когда продукт тестирует продукт малое количество людей, которые в итоге будут использовать его после релиза. Это помогает учесть пожелания конечных пользователей.
     Очень важно лиду или менеджеру проекта передавать информацию тестировщикам и разработчикам о пожеланиях заказчика, на какие частые сбои в продукте натыкались пользователи для того, чтобы сделать его более понятным.

Этап 5. Основное тестирование
    Тестирование программного обеспечения является самым длительным и объемным процессом. Здесь формируются репорты о найденных дефектах, выполняется набор тестовых сценариев, создается тестовая среда, выполняется тестирование, виды которого были задокументированы на этапе создания тестовой документации. Смоук- и регресс-тестирования являются одними из основных видов тестирования, которые проводятся на данном этапе.
Важно понимать: невозможно найти все ошибки в продукте. Но и не найти ошибки при тестировании можно считать провалом. Главная цель — не сделать идеальный продукт без ошибок, а найти максимальное количество дефектов, которые потенциально могут сломать систему.

Этап 6. Стабилизация
     На нем заканчивается работа с пожеланиями заказчика и фиксируются найденные баги. Он является связующим звеном между командой тестирования и командой разработчиков. На протяжении создания онлайн-ресурса команда разработчиков занималась своими делами, реализуя «хотелки» заказчика, а тестировщики репортили о новых дефектах. А на этапе стабилизации разработчики начинают слушать тестировщиков, устраняя то, что уже работает, но некорректно.
Если продукт существует в какой-то большой системе, то на данном этапе также проверяется коммуникация системы и продукта, то есть проводится интеграционное тестирование.

Этап 7. Эксплуатация и поддержка
     После устранения дефектов команда разработчиков переходит в этап тестирования продукта в продакшн-среде. Так как многие ставят точку на проекте после релиза, очень важно подметить, что здесь происходит не только релиз продукта, но и пост-релизовая поддержка. 
При всем желании нельзя учесть все нюансы использования, воссоздать ту среду, в которой будет использован продукт. Поэтому на данном этапе необходимо сделать акцент на том, что говорят пользователи, важно прислушиваться к их мнению, поскольку они участвуют не только в использовании продукта, но и тестировании, натыкаясь на ненайденные ошибки. Ваш продукт становится частью жизнедеятельности людей, поэтому устранение дефектов и их поиск проводятся быстро, но тщательно. Не всегда конечный пользователь может предоставить информацию о том, что он сделал для получения ошибки, поэтому за повторение дефекта берется QA-команда.
Изучив все этапы тестирования сложно выделить главный – каждый из них важен по-своему. Тестирование является долгим и кропотливым процессом, результатом которого является выявленная ошибка в системе. Тестировщик должен четко формулировать свою позицию, почему найденная ошибки — действительно дефект, должен прислушиваться после релиза к позиции конечного пользователя и помнить, что ничто в этом мире не идеально.

====================================================================================================================================

11.Как вы тестируете продукт, если требования еще не зафиксированы?
   Если спецификация требований недоступна для продукта, тогда план тестирования может быть создан на основе предположений, сделанных относительно продукта. Но мы должны хорошо документировать все предположения в плане тестирования.

====================================================================================================================================

12.Как вы узнаете, было ли создано достаточно тестов для тестирования продукта?
     Прежде всего, мы проверим, охватывает ли каждое требование хотя бы один Test case. Если да, то можно сказать, что тестовых примеров достаточно для тестирования продукта. 

====================================================================================================================================

13.Что подразумевается под тестовыми данными?
Тестовые данные - это набор входных значений, необходимых для выполнения Test case. Тестировщики определяют данные в соответствии с требованиями. Они могут сделать это вручную или использовать инструменты генерации. 

====================================================================================================================================

14.Что такое бета-тестирование?
   Бета-тестирование происходит на конечных пользователях. Это нужно для обеспечения обратной связи.  Существуют различные типы бета-тестов в тестировании ПО, и они заключаются в следующем: 
-Традиционное бета-тестирование: продукт распространяется на целевой рынок, и соответствующие данные собираются по всем аспектам. Эти данные могут быть использованы для улучшения продукта. 
-Публичное бета-тестирование: продукт публикуется во внешнем мире через онлайн-каналы, и данные могут быть получены от любого пользователя. На основе обратной связи могут быть сделаны улучшения продукта. 
-Техническое бета-тестирование: продукт передается во внутреннюю группу организации и собирает отзывы / данные от сотрудников организации. 
-Целевая бета-версия: продукт выпущен на рынок для сбора отзывов об особенностях программы. 
-Бета-версия после выпуска. Продукт выпущен на рынок, и данные собираются для внесения улучшений в будущем выпуске продукта.

====================================================================================================================================

15.Что означает пилотное тестирование? (Pilot)
    PILOT testing определяется как тип тестирования программного обеспечения, который проверяет компонент системы или всю систему в режиме реального времени. 
     Целью пилотного теста является оценка осуществимости, времени, стоимости, риска и эффективности исследовательского проекта.
 Это тестирование проводится точно между UAT и Production. В пилотном тестировании выбранная группа конечных пользователей пробует тестируемую систему и предоставляет обратную связь до полного развертывания системы. Другими словами, это означает проведение генеральной репетиции для последующего теста на удобство использования. Пилотное тестирование помогает в раннем обнаружении ошибок в Системе.
      Пилотное тестирование связано с установкой системы на площадке заказчика (или в среде, моделируемой пользователем) для тестирования на предмет постоянного и регулярного использования. Выявленные недостатки затем отправляются команде разработчиков в виде отчетов об ошибках, и эти ошибки исправляются в следующей сборке системы. Во время этого процесса иногда приемочное тестирование также включается как часть тестирования на совместимость. Это происходит, когда система разрабатывается для замены старой. 

====================================================================================================================================

17.Что такое бизнес – логика (domain)?
     Бизнес – логика (domain) это то, что конкретная программа по задумке должна сделать. Например, в складской программе проверка на возможность отправить товар (вдруг его нет в наличии). Это правила, которые должны соблюдаться в данной конкретной программе, определенные бизнес-клиентом. Слои приложения – слой пользовательского интерфейса, слой бизнес логики, слой сохранения данных.

====================================================================================================================================

18.Какие существуют основные виды тестирования ПО?
     *Функциональные виды («Что?» - проверяет весь функционал продукта):
1)Функциональное тестирование (Functional testing)
2)Тестирование взаимодействия (Interoperability testing)
     *Нефункциональное («Как?»):
1)Производительности (Performance)
    -Тестирование емкости/способностей (Capacity testing)
    -Стрессовое (Stress testing)
    -Нагрузочное (Load testing)
    -Объемное тестирование (Volume testing)
    -Выносливости (Soak/Endurance testing)
    -Стабильности/надежности (Stability / Reliability testing)
    -Шиповое (Spike)
    -Отказоустойчивости (Stability testing)
    -Масштабируемости (Scalability test)
2)Отказ и восстановление (Failover and Recovery testing)
3)Удобство пользования (Usability testing)
4)Тестирование установки (Installation testing)
5)Тестирование безопасности (Security and Access Control testing)
6)Конфигурационное (Configuration testing)
   *Связанное с изменениями:
1)Регрессионное (Regression testing)
2)Санитарное (Sanity testing)
3)Дымовое (Smoke testing)
4)Тестирование сборки (Build Verification testing)

====================================================================================================================================

19.Методы тестирования?
(White/Black/Grey Box)
    Черный ящик:
Мы не знаем, как устроена внутри тестируемая система. Тестирование методом «черного ящика», также известное как тестирование, основанное на спецификации или тестирование поведения – техника тестирования, основанная на работе исключительно с внешними интерфейсами тестируемой системы. – тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента или системы. – тест-дизайн, основанный на технике черного ящика – процедура написания или выбора тест-кейсов на основе анализа функциональной или нефункциональной спецификации компонента или системы без знания ее внутреннего устройства. Почему именно «черный ящик»? Тестируемая программа для тестировщика – как черный непрозрачный ящик, содержания которого он не видит. Целью этой техники является поиск ошибок в таких категориях: – неправильно реализованные или недостающие функции; – ошибки интерфейса; – ошибки в структурах данных или организации доступа к внешним базам данных; – ошибки поведения или недостаточная производительности системы; Таким образом, мы не имеем представления о структуре и внутреннем устройстве системы. Нужно концентрироваться на том, ЧТО программа делает, а не на том, КАК она это делает. Пример: Тестировщик проводит тестирование веб-сайта, не зная особенностей его реализации, используя только предусмотренные разработчиком поля ввода и кнопки. Источник ожидаемого результата – спецификация. Поскольку это тип тестирования, по определению он может включать другие его виды. Тестирование черного ящика может быть как функциональным, так и нефункциональным. Функциональное тестирование предполагает проверку работы функций системы, а нефункциональное – соответственно, общие характеристики нашей программы. Техника черного ящика применима на всех уровнях тестирования (от модульного до приемочного), для которых существует спецификация. Например, при осуществлении системного или интеграционного тестирования, требования или функциональная спецификация будут основой для написания тест-кейсов. Техники тест-дизайна, основанные на использования черного ящика, включают: – классы эквивалентности; – анализ граничных значений; – таблицы решений; – диаграммы изменения состояния; – тестирование всех пар. Преимущества: – тестирование производится с позиции конечного пользователя и может помочь обнаружить неточности и противоречия в спецификации; – тестировщику нет необходимости знать языки программирования и углубляться в особенности реализации программы; – тестирование может производиться специалистами, независимыми от отдела разработки, что помогает избежать предвзятого отношения; – можно начинать писать тест-кейсы, как только готова спецификация. Недостатки: – тестируется только очень ограниченное количество путей выполнения программы; – без четкой спецификации (а это скорее реальность на многих проектах) достаточно трудно составить эффективные тест-кейсы; – некоторые тесты могут оказаться избыточными, если они уже были проведены разработчиком на уровне модульного тестирования; Противоположностью техники черного ящика является тестирование методом белого ящика, речь о котором пойдет ниже.
     Белый ящик:
Тестирование методом белого ящика (также: прозрачного, открытого, стеклянного ящика; основанное на коде или структурное тестирование) – метод тестирования ПО, который предполагает, что внутренняя структура/устройство/реализация системы известны тестировщику. Мы выбираем входные значения, основываясь на знании кода, который будет их обрабатывать. Точно так же мы знаем, каким должен быть результат этой обработки. Знание всех особенностей тестируемой программы и ее реализации – обязательны для этой техники. Тестирование белого ящика – углубление во внутреннее устройство системы, за пределы ее внешних интерфейсов. Техника белого ящика применима на разных уровнях тестирования – от модульного до системного, но главным образом применяется именно для реализации модульного тестирования компонента его автором. Преимущества: – тестирование может производиться на ранних этапах: нет необходимости ждать создания пользовательского интерфейса; – можно провести более тщательное тестирование, с покрытием большого количества путей выполнения программы. Недостатки: – для выполнения тестирования белого ящика необходимо большое количество специальных знаний Основным методом тестирования Белого ящика является анализ покрытия кода. Анализ покрытия кода устраняет пробелы в наборе тестовых примеров. Он определяет области программы, которые не покрываются набором Test case. После выявления пробелов вы создаете контрольные примеры для проверки непроверенных частей кода, тем самым повышая качество программного продукта. Охват операторов: - Этот метод требует, чтобы каждое возможное утверждение в коде было проверено хотя бы один раз в процессе тестирования разработки ПО.
Покрытие ветвления - этот метод проверяет все возможные пути (если-еще и другие условные циклы) программного приложения.
Помимо вышесказанного, существует множество типов покрытия, таких как покрытие условий, покрытие нескольких условий, покрытие пути, покрытие функций и т. д. Каждый метод имеет свои достоинства и пытается протестировать (охватить) все части программного кода. Используя покрытие Statement и Branch, вы обычно достигаете 80-90% покрытия кода, что является достаточным.
     Серый ящик:
Тестирование методом серого ящика – метод тестирования ПО, который предполагает комбинацию White Box и Black Box подходов. То есть, внутреннее устройство программы нам известно лишь частично. Предполагается, например, доступ к внутренней структуре и алгоритмам работы ПО для написания максимально эффективных тест-кейсов, но само тестирование проводится с помощью техники черного ящика, то есть, с позиции пользователя. Либо нам не доступна внутренняя реализация функций, но мы знаем на уровень ниже, чем пользователи – интерфейсы/эндпоинты и т.п. Техника серого ящика применима на разных уровнях тестирования – от модульного до системного, но главным образом применяется на интеграционном уровне для проверки взаимодействия разных модулей программы. Пример тестирования «серого ящика»: при тестировании веб-сайтов на битые ссылки, если тестировщик сталкивается с какой-либо проблемой с этими ссылками, он может сразу же внести изменения в HTML-код и проверить в реальном времени. Методы:
Матричное тестирование: этот метод тестирования включает в себя определение всех переменных, которые существуют в их программах. 
Регрессионное тестирование: чтобы проверить, повлияло ли изменение в предыдущей версии другие аспекты программы в новой версии. 
Тестирование ортогональных массивов или OAT: обеспечивает максимальное покрытие кода с минимальным количеством тестов. 
Pattern testing: это тестирование выполняется на данных истории предыдущих дефектов системы. В отличие от тестирования черного ящика, в тестировании серого ящика копаются в коде и определяют причину сбоя.

====================================================================================================================================

20.Что такое пирамида / уровни тестирования?
     «Пирамида тестов» — метафора, которая означает группировку тестов программного обеспечения по разным уровням детализации. Она также дает представление, какое количество тестов должно быть в каждой из этих групп. В тесте более высокого уровня вы не тестируете всю условную логику и пограничные случаи, которые уже покрыты юнит-тестами более низкого уровня. Убедитесь, что тест высокого уровня фокусируется только на том, что не покрыто тестами более низкого уровня. Правило трех А(AAA) (arrange, act, assert) или триада «дано, когда, тогда» — хорошая мнемоника, чтобы поддерживать хорошую структуру тестов. 

====================================================================================================================================

21.Что такое деструктивное/разрушающее/негативное тестирование? (DT — Destructive testing)
     НЕГАТИВНОЕ ТЕСТИРОВАНИЕ - тип тестирования ПО для поиска точек отказа в программном обеспечении, который проверяет систему на обработку исключительных ситуаций (срабатывание валидаторов на некорректные данные), а также проверяет, что вызываемая приложением функция не выполняется при срабатывании валидатора. Неожиданные условия могут быть чем угодно, от неправильного типа данных до хакерской атаки. 
     Целью отрицательного тестирования является предотвращение сбоя приложений из-за некорректных входных данных. Просто проводя положительное тестирование, мы можем только убедиться, что наша система работает в нормальных условиях. Мы должны убедиться, что наша система может справиться с непредвиденными условиями, чтобы обеспечить 100% безошибочную систему. Типичные примеры: ввести неправильно составленный e-mail и номер телефона, загрузить файл не предусмотренного расширения или размера.      Для деструктивного тестирования существует множество способов его тестирования: 
*Метод анализа точек отказа: это пошаговое прохождение системы, проводящее оценку того, что может пойти не так в разных точках. Для этой стратегии может быть использована помощь BA (Business Analyst). 
*Экспертная проверка тестировщика: проанализируйте или дайте на ревью ваши Test вашему коллеге-тестировщику, который менее знаком с системой/функцией 
*Бизнес-анализ тестовых случаев. Конечные пользователи или эксперты могут подумать о многих допустимых сценариях, которые иногда тестировщики могут не учитывать или упустить, так как все их внимание будет сосредоточено на тестировании требований. 
*Проведите предварительное тестирование с использованием контрольных таблиц (run sheets). Исследовательское тестирование с использованием контрольных таблиц поможет определить, что было проверено, повторить тесты и позволит вам контролировать охват тестами. 
*Используйте другой источник: вы можете попросить кого-нибудь сломать программный продукт и проанализировать различные сценарии.

====================================================================================================================================

22.Что такое недеструктивное/неразрушающее/позитивное тестирование? (NDT – Non Destructive testing)
     НЕДЕСТРУКТИВНОЕ ТЕСТИРОВАНИЕ - это тип тестирования программного обеспечения, который включает в себя правильное взаимодействие с программным обеспечением. Другими словами, неразрушающее тестирование (NDT) также можно назвать позитивным тестированием или тестированием «счастливого пути». Это дает ожидаемые результаты и доказывает, что программное обеспечение ведет себя так, как ожидалось. 
     Пример:  Ввод правильных данных в модуль входа в систему и проверка, принимает ли он учетные данные и переходит на следующую страницу

====================================================================================================================================


23.Что подразумевается под компонентным/модульным/юнит тестированием? (Component/Module/Unit testing)
     Модульные тесты используются для тестирования какого-либо одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде. Очевидно, что это тестирование методом белого ящика и чаще всего оно проводится самими разработчиками. 
      Целью тестирования модуля является не демонстрация правильного функционирования модуля, а демонстрация наличия ошибки в модуле, а также в определении степени готовности системы к переходу на следующий уровень разработки и тестирования. На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов. Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования. Изоляция тестируемого блока достигается с помощью заглушек (stubs), манекенов (dummies) и макетов (mockups).

 Unit testing	                                                                                                                                                                                                                 Сomponent testing
Тестирование отдельных программ, модулей, функций для демонстрации того, что программа выполняется согласно спецификации               Тестирование каждого объекта или частей программного обеспечения отдельно с или без изоляции других объектов
Проверка в(на) соответствии с design documents	                                                                                                                                                 Проверка в(на) соответствии с test requirements, use case
Пишутся и выполняются(обычно) разработчиками	                                                                                                                                                 Тестировщиками
Выполняется первым	                                                                                                                                                                                                 Выполняется после Unit

====================================================================================================================================


