1)SDLC – жизненный цикл программного обеспечения.
Этапы SDLC:
--Анализ требований отвечает на вопрос «Какие проблемы требуют решений?»
--Планирование отвечает на вопрос «Что мы хотим сделать?»
--Проектирование и дизайн отвечает на вопрос «Как мы добьемся наших целей?»
--Разработка ПО регулирует процесс создания продукта.
--Тестирование регулирует обеспечение качественной работы продукта.
--Развертывание регулирует использование финального продукта.

Этап 1: Анализ требований
На этом этапе SDLC вам необходимо получить обратную связь и поддержку от соответствующих внутренних и внешних заинтересованных сторон. Некоторые идеи будут включать ваших клиентов, дизайнеров, вашего начальника или других технических специалистов команды. В целом вы хотите ответить на следующий вопрос: «Какие проблемы требуют решений?» Быть внимательным и делать заметки будет очень полезно на этом этапе.

Этап 2: Планирование
На этом этапе вы ищете ответ на следующий вопрос: «Что вы хотите сделать?» Этот вопрос может вдохновить вас на понимание юнит-экономики вашего плана (затраты и выгоды), факторов снижения рисков и ожидаемых стоимостей. По аналогии с планированием отпуска, вам нужно будет разложить ваши вещи и подумать о том, что следует взять с собой.

Хороший пример:

Я много читал об истории Инстаграма, чей этап планирования занял невероятно много времени. Это совпало с бурным ростом социальных сетей, поэтому взаимодействие пользователей с продуктом во многом все еще было неизвестно. Разработчики знали, что сильный первичный опыт (съемка, редактирование и обмен фотографиями) обеспечит рост, успех и высокую конверсию, а корректное планирование упростит проектирование, поэтому планировали соответствующе и тратили на дизайн много времени. Они всегда смотрели на шаг вперед и думали о будущем социальных сетей и электронной коммерции.
Планируйте то, что вы можете контролировать, и помните о вещах, планировать которые вы не сможете. Это поможет вам получить прочную основу для перехода к третьему этапу.

Этап 3: Проектирование и дизайн
К этому этапу вы уже должны знать требования вашего продукта и в целом понимать чего вы вообще хотите, и прежде чем приступить к написанию кода, этого понимания должно быть достаточно для ответа на следующий вопрос: «Как мы добьемся наших целей?» Иначе говоря, вам необходимо понять, что именно вы оптимизируете и проектировать соответствующе.

Допустим, вы хотите создать безопасное, высокопроизводительное, эффективное и выдерживающее нагрузки приложение. Какой из этих четырех принципов наиболее для вас наиболее важен? Почему? Согласны ли с этим заинтересованные стороны из первого этапа? Важно обеспечить одобрение всех участников.

После фазы дизайна вы наконец-то сможете засесть за клавиатуры, и внесение изменений в отношении времени и потраченных ресурсов будет неуклонно расти, а также буду постепенно накапливаться всевозможные малые факторы. В этой фазе для принятия окончательных решений по вопросам дизайна я рекомендую учитывать несколько основных его элементов: операционное превосходство, безопасность, надежность, эффективность производительности, и оптимизация затрат.

Этап 4: Разработка ПО

На этапе разработки вы стремитесь не столько отвечать на вопросы, сколько произвести результаты, или, говоря точнее, вам необходимо склоняться к действиям и создать прототип или систему, испытать которую смогут другие. На этом этапе ваша задача – заручиться доверием заинтересованных сторон через воплощение образа мышления разработчика. Для соответствия результата ожиданиям критично при начале разработки следовать первым трем этапам.

Доставайте ваш компьютер, убедитесь, что окружение способствует рабочей атмосфере, хватайте ваш горячий кофе – и приступайте к делу.

Этап 5: Тестирование
Сотрудники в футболках с надписями вида «Разрабатывать круто, тестировать не очень» были для меня привычным зрелищем, но вы должны понимать, что не получится создать финальную версию продукта, пока вы на нем собаку не съедите. По завершению этого этапа вы должны будете в состоянии обеспечить рабочее состояние продукта. Отслеживайте ошибки и неточности, выслушивайте чужие точки зрения, и глубоко погружайтесь в вопрос с целью поиска тормозящих выход финального продукта ошибок. Вам просто необходимо обеспечить прочную основу.

Этап 6: Развертывание
Возьмите ваш продукт и пользуйтесь им. Предложите заинтересованным сторонам из первого этапа пользоваться вашим продуктом в естественных условиях, начните отслеживать вовлеченность в продажи. Снова и снова прислушивайтесь к пользователям, ведь благодаря обратной связи через опросы и рекомендации вы сможете вернуться к первой фазе и начать собирать новые требования. И не забудьте отпраздновать релиз.


2)Классификация видов тестирования

1. Цель
Каждый программный продукт должен выполнять одну или несколько ключевых задач. От приложения с гео-картами мы ожидаем точной ориентации в пространстве, от сайта интернет-магазина ― корректного поиска товаров по заданным параметрам и т. д. Но те же программные продукты мы можем протестировать и с точки зрения дизайна.

Таким образом, анализ ПО с позиции его ключевых или вспомогательных функций определяет тип тестирования:

Функциональное
Нефункциональное
Функциональное тестирование направлено на проверку того, какие функции ПО реализованы, и того, насколько верно они реализованы.

Что входит в функциональное тестирование ПО

Нефункциональное – проверка корректности работы нефункциональных требований. Оценивается, КАК программный продукт работает. Эта проверка включает в себя следующие виды:

Тестирование производительности – работа ПО под определённой нагрузкой.
Тестирование пользовательского интерфейса – удобство пользователя при взаимодействии с разными параметрами интерфейса (кнопки, цвета, выравнивание и т. д.).
Тестирование UX – правильность логики использования программного продукта.
Тестирование защищенности – определение безопасности ПО: защищено ли оно от атак хакеров, несанкционированного доступа к данным и т. д.
Инсталляционное тестирование – оценка вероятности возникновения проблем при установке, удалении, а также обновлении ПО.
Тестирование совместимости – тестирование работы программного продукта в определённом окружении.
Тестирование надежности – работа программы при длительной средней ожидаемой нагрузке.
Тестирование локализации –оценка правильности версии программного продукта (языковой и культурный аспекты).


2. Степень автоматизации
В зависимости от того, используют ли тестировщики дополнительные программные средства для тестирования приложений или программ, тестирование бывает:

Мануальное (ручное) – без использования дополнительных программных средств, т. е. «вручную».
Автоматизированное – с использованием программных средств (более детально в описании курса по автоматизации тестирования ПО).
Каждый из подходов имеет свои преимущества и недостатки. Ручное тестирование проще освоить, оно широко применяется на проектах всех типов, но мануальные проверки отличаются монотонностью. А вот написание тестов даёт больше возможностей для творческой реализации, но автоматизация требует базовых навыков программирования.
Подробнее о плюсах и минусах этих типов тестирования мы рассказали в нашей статье.

3. Позитивность сценария
Этот подход определяет поведение системы в привычных и экстремальных условиях.

Позитивная проверка – оценка ожидаемого поведения. Это тестирование проводится в первую очередь, ведь позволяет определить корректность работы программы.
Негативная – определение устойчивости системы в нестандартной ситуации. Например, неожиданный сценарий взаимодействия пользователя с интерфейсом.
Эти типы тестирования нередко проводятся параллельно. Ведь работая над некоторой функциональностью, тестировщику проще оценить её поведение и в стандартных, и в нестандартных условиях.

4. Доступ к коду программного продукта
В процессе тестирования инженер может работать с ПО, не обращаясь к его коду, а может определить правильность работы, взглянув на код. По доступу к коду программного продукта тестирование делится на:

Тестирование «белого ящика» – с доступом к коду.
Тестирование «черного ящика» – без доступа к коду продукта.
Тестирование «серого ящика» – на основе ограниченного знания внутренней структуры ПО. Часто говорят, что это смесь тестирования «белого ящика» и «чёрного ящика», но это в корне неверно. В данном случае тестировщик не работает с кодом программного продукта, но он знаком с внутренней структурой программы и взаимодействием между компонентами.
Виды тестирования по доступу к коду программного продукта (белое, черное, серое)

Проверка программного продукта по каждому из сценариев требует достаточно глубоких знаний. К примеру, об особенностях тестирования «чёрного ящика» в своей книге подробно рассказал Борис Бейзер. Это фундаментальная работа, с которой полезно ознакомиться каждому на старте работы в QA. Об этой и других полезных книгах мы рассказали в статье.

5. Уровень
Этот пункт определяет объект тестирования.

Модульное / юнит-тестирование – проверка корректной работы отдельных единиц ПО, модулей. Этот вид тестирования могут выполнять сами разработчики.
Интеграционное тестирование – проверка взаимодействия между несколькими единицами ПО.
Системное – проверка работы приложения целиком.
Приёмочное – оценка соответствия заявленным требованиям к программному продукту.
Переход на каждую новую ступень – движение от микроуровня к макро. Это важный этап тестирования, ведь безошибочно написанные модули могут просто не работать вместе.
Узнать больше об особенностях каждого из уровней тестирования вы сможете на базовом курсе Академии, а закрепить навыки – на продвинутом курсе.

6. Исполнитель
От объекта тестирования движемся к его субъекту. Вы могли слышать об альфа- и бета-тестировании. А поучаствовать в одном из них можно, даже не будучи тестировщиком. Итак, по исполнителю тестирование делится на:

Альфа-тестирование – проверка программного продукта на поздней стадии разработки. Проводится разработчиками или тестировщиками.
Бета-тестирование – оценка ПО перед выходом на рынок в фокус-группе или добровольцами. Отзывы собираются, анализируются и учитываются при внесении правок.
7. Формальность
Этот пункт определяет подготовленность тестировщика перед началом проверки.

Тестирование по тестам – использование написанных заранее тест-кейсов.
Исследовательское тестирование – одновременная разработка тестов и их использование.
Свободное тестирование – проверка качества без разработки тестов и написания документации. Основывается на интуиции и опыте тестировщика.
Начинающие тестировщики редко работают на свободном уровне. А вот опытные QA-специалисты могут позволить себе проверку без дополнительной подготовки. Мастерство растёт со временем, как и оплата труда тестировщика. О том, сколько получают инженеры, читайте в нашем блоге.

8. Важность
Дымовое тестирование – проверка самой важной функциональности программного продукта.
Тестирование критического пути – проверка функциональности, используемой типичными пользователями в повседневной деятельности.
Расширенное тестирование – проверка всей заявленной функциональности.

3) Что такое авторизация, аутентификация, валидация, идентификация.

Идентификация — процесс распознавания пользователя по его идентификатору.
Аутентификация — процедура проверки подлинности, доказательство что пользователь именно тот, за кого себя выдает.
Авторизация — предоставление определённых прав.
Верификация — это подтверждение того, что задание было выполнено в полном соответствии с требованиями заказчика. 
Валидация — это проверка того, так ли как надо результирующее изделие (продукт) функционирует на практике.

4)Распишите жизненный цикл бага.
Новый (New). Тестировщик нашел баг, дефект успешно занесен в «Bug-tracking» систему.
Открыт (Opened). После того, как тестировщик отправил ошибку, она либо автоматически, либо вручную назначается на человека который должен её проанализировать (обычно Project Manager). В зависимости от решения менеджера проекта, баг может быть:
  Отложен (Deferred). Исправление этого бага не несет ценности на данном этапе разработки или по другим, отсрочивающим его исправление причинам.
  Отклонен (Rejected). По разным причинам дефект может и не считаться дефектом или считаться неактуальным дефектом, что вынуждает отклонить его.
  Дубликат (Duplicate). Если описанная ошибка уже ранее была внесена в «Bug-tracking» систему, то статус такой ошибки меняется на «дубликат».
Назначен (Assigned). Если ошибка актуальна и должна быть исправлена в следующей сборке (build), происходит назначение на разработчика который должен исправить ошибку.
Когда наличие дефекта неопровержимо, его путь может привести к следующим статусам:
  Исправлен (Fixed). Ответственный за исправление бага разработчик заявляет, что устранил дефект.
В зависимости от того, исправил ли разработчик дефект, дефект может быть:
  Проверен (Verified). Тестировщик проверяет, действительно ли ответственный разработчик исправил дефект, или все-таки разработчик безответственный. Если бага больше нет, он получает данный статус.
  Повторно открыт (Reopened). Если опасения тестировщика оправданы и баг в новом билде не исправлен – он все так же потребует исправления, поэтому заново открывается.
  Закрытый (Closed). В результате определенного количества циклов баг все-таки окончательно устранен и больше не потребует внимания команды – он объявляется закрытым.